<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Estructura Territorial</title>
    <link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <!-- Leaflet.markercluster (clustering for ET-27) -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css"
    />
    <script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>

    <style>
      .et27-toolbar {
        position: absolute;
        top: 12px;
        right: 12px;
        z-index: 1200;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 14px;
        padding: 8px;
        box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1);
        display: flex;
        gap: 6px;
        align-items: center;
      }
      .et27-btn {
        border: 1px solid #e5e7eb;
        background: #f8fafc;
        padding: 6px 10px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 12px;
      }
      .et27-btn:hover {
        background: #eef2f7;
      }

      .et27-kpis {
        position: absolute;
        bottom: 14px;
        left: calc(var(--sidebar-w) + 12px);
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 10px 12px;
        z-index: 1100;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        max-width: 58%;
      }
      .et27-kpi {
        min-width: 140px;
      }
      .et27-kpi .t {
        font-size: 11px;
        color: #64748b;
      }
      .et27-kpi .v {
        font-size: 18px;
        font-weight: 700;
        color: #111827;
      }

      .et27-legend {
        position: absolute;
        bottom: 14px;
        right: 14px;
        z-index: 1100;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 12px;
        padding: 10px 12px;
        box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
        min-width: 240px;
      }
      .et27-legend h4 {
        margin: 0 0 6px 0;
        font-size: 12px;
        color: #111827;
      }
      .et27-legend .row {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        margin: 4px 0;
      }
      .et27-dot {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        display: inline-block;
        border: 1px solid #11182722;
      }

      .et27-panel {
        position: absolute;
        top: 80px;
        right: 12px;
        z-index: 1200;
        width: 380px;
        max-height: 62%;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 14px;
        box-shadow: 0 14px 36px rgba(0, 0, 0, 0.14);
        display: none;
        overflow: auto;
      }
      .et27-panel header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 12px;
        border-bottom: 1px solid #f1f5f9;
      }
      .et27-panel header .ttl {
        font-weight: 700;
        font-size: 14px;
      }
      .et27-panel header .act {
        display: flex;
        gap: 6px;
      }
      .et27-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 12px;
      }
      .et27-table th,
      .et27-table td {
        border-bottom: 1px solid #f1f5f9;
        padding: 8px 10px;
        text-align: left;
      }
      .et27-table th {
        position: sticky;
        top: 0;
        background: #fff;
        z-index: 1;
      }
    </style>

    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        font-family: "Segoe UI", Arial, sans-serif;
        background: #f4f4f4;
      }
      :root {
        --sidebar-w: 320px;
      }
      #panel-lateral {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: var(--sidebar-w);
        height: 100%;
        background: linear-gradient(180deg, #8ea3ad 0%, #dfe6e9 100%);
        color: #2c3e50;
        border-right: 1px solid #b2bec3;
        display: flex;
        flex-direction: column;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
        align-items: stretch;
        z-index: 2000;
      }
      #panel-header {
        background: #b2bec3;
        color: #2c3e50;
        padding: 12px 15px;
        display: flex;
        align-items: center;
        font-size: 18px;
        font-weight: bold;
      }
      #panel-header img {
        height: 32px;
        margin-right: 10px;
      }
      #map {
        position: absolute;
        top: 0;
        left: var(--sidebar-w);
        width: calc(100% - var(--sidebar-w));
        height: 100%;
      }

      #sec-search {
        position: relative;
      } /* contenedor del buscador */
      #sec-suggest {
        z-index: 3000;
      }
      #sec-suggest {
        position: absolute;
        left: 12px;
        right: 12px;
        top: 46px; /* ajusta según tu input */
        max-height: 220px;
        overflow: auto;
      }
      /* la lista queda clickeable */

      /* Etiqueta de la SECCIÓN seleccionada (rosa tenue) */
      .sec-label {
        background: rgba(255, 235, 238, 0.96); /* #ffebee */
        border: 1px solid #e91e63;
        color: #880e4f;
        padding: 2px 6px;
        border-radius: 8px;
        font-size: 12px;
        font-weight: 700;
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
      }

      /* Etiquetas de SECCIONES ADYACENTES (azul/gris tenue) */
      .sec-label-adj {
        background: rgba(227, 242, 253, 0.94); /* #e3f2fd */
        border: 1px solid #64b5f6;
        color: #0d47a1;
        padding: 1px 5px;
        border-radius: 8px;
        font-size: 11px;
        font-weight: 600;
        pointer-events: none;
        white-space: nowrap;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.12);
      }

      /* Panel flotante sección */
      #sec-info {
        position: absolute;
        right: 16px;
        bottom: 16px;
        width: 320px;
        max-width: 38vw;
        min-width: 260px;
        background: #ffffff;
        border: 1px solid #cfd8dc;
        border-radius: 10px;
        box-shadow: 0 10px 24px rgba(0, 0, 0, 0.15);
        resize: both;
        overflow: auto;
        z-index: 4000;
        display: none;
        pointer-events: auto;
      }
      #sec-info .hdr {
        cursor: move;
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: linear-gradient(180deg, #eceff1, #e3f2fd);
        padding: 8px 12px;
        border-bottom: 1px solid #cfd8dc;
        font-weight: 700;
        color: #263238;
      }

      #sec-info .hdr .btn-close {
        cursor: pointer;
        border: none;
        outline: none;
        background: #ffcdd2; /* rosa tenue */
        color: #880e4f;
        width: 24px;
        height: 24px;
        line-height: 24px;
        border-radius: 6px;
        font-size: 16px;
        font-weight: 800;
      }
      #sec-info .hdr .btn-close:hover {
        background: #ef9a9a;
      }
      #sec-info .body {
        padding: 10px 12px;
        color: #37474f;
      }
      #sec-info .row {
        display: flex;
        justify-content: space-between;
        margin: 6px 0;
      }
      #sec-info .k {
        color: #607d8b;
      }
      #sec-info .v {
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div id="panel-lateral">
      <div id="panel-header">
        <!-- <img src="assets/img/logo.png" alt="Logo"/> -->
        <span>Estructura Territorial</span>
      </div>
      <!-- Aquí va el contenido del panel lateral -->

      <!-- Buscador de secciones -->
      <div
        id="sec-search"
        style="
          padding: 10px 12px;
          border-top: 1px solid #cbd5e1;
          background: #eef2f7;
        "
      >
        <div style="display: flex; gap: 8px; align-items: center">
          <input
            id="sec-q"
            type="text"
            placeholder="Buscar sección (ej. 1234 o '1234 León')"
            autocomplete="off"
            autocorrect="off"
            spellcheck="false"
            enterkeyhint="search"
            style="
              flex: 1;
              padding: 6px 8px;
              border: 1px solid #94a3b8;
              border-radius: 6px;
            "
          />
          <label style="white-space: nowrap; font-size: 12px">
            <input id="sec-global" type="checkbox" /> Todo el estado
          </label>
        </div>
        <ul
          id="sec-suggest"
          style="
            margin: 8px 0 0 0;
            padding: 0;
            list-style: none;
            max-height: 180px;
            overflow: auto;
            border: 1px solid #cbd5e1;
            border-radius: 6px;
            background: #fff;
            display: none;
          "
        ></ul>
      </div>

      <div
        id="mini-universe"
        style="
          padding: 12px 12px 6px 12px;
          background: #eef2f7;
          border-top: 1px solid #cbd5e1;
        "
      >
        <div class="row" style="margin-bottom: 8px">
          <label
            ><input type="checkbox" id="mini-all-state" /> Estado
            completo</label
          >
        </div>
        <div class="row" style="margin-bottom: 8px">
          <label>Municipio</label>
          <select id="mini-sel-mun" style="width: 100%; padding: 6px">
            <option value="">— Ninguno —</option>
          </select>
        </div>
        <div class="row" style="margin-bottom: 8px">
          <label>Distrito Federal</label>
          <select id="mini-sel-df" style="width: 100%; padding: 6px">
            <option value="">— Ninguno —</option>
          </select>
        </div>
        <div class="row" style="margin-bottom: 8px">
          <label>Distrito Local</label>
          <select id="mini-sel-dl" style="width: 100%; padding: 6px">
            <option value="">— Ninguno —</option>
          </select>
        </div>
        <div class="hint" style="font-size: 12px; color: #64748b">
          Elige solo uno. Al cambiar, el mapa se actualiza.
        </div>
      </div>
    </div>
    <div id="map"></div>

    <!-- ET-27: Toolbar -->
    <div class="et27-toolbar" id="et27-toolbar">
      <button class="et27-btn" id="et27-btn-load">Cargar ET-27</button>
      <button class="et27-btn" id="et27-btn-cob-sec">
        Cobertura por Sección
      </button>
      <button class="et27-btn" id="et27-btn-cob-cas">
        Cobertura por Casilla
      </button>
      <button class="et27-btn" id="et27-btn-faltantes">Faltantes</button>
    </div>

    <!-- ET-27: KPIs -->
    <div class="et27-kpis" id="et27-kpis" style="display: none">
      <div class="et27-kpi">
        <div class="t">Puntos ET-27</div>
        <div class="v" id="et27-kpi-puntos">—</div>
      </div>
      <div class="et27-kpi">
        <div class="t">Casillas</div>
        <div class="v" id="et27-kpi-casillas">—</div>
      </div>
      <div class="et27-kpi">
        <div class="t">% Secciones Cubiertas</div>
        <div class="v" id="et27-kpi-sec-cubiertas">—</div>
      </div>
      <div class="et27-kpi">
        <div class="t">% Casillas Cubiertas</div>
        <div class="v" id="et27-kpi-cas-cubiertas">—</div>
      </div>
    </div>

    <!-- ET-27: Leyenda -->
    <div class="et27-legend" id="et27-legend" style="display: none">
      <h4>Estructura (roles)</h4>
      <div class="row">
        <span class="et27-dot" style="background: #6cab5a"></span> Simpatizante
      </div>
      <div class="row">
        <span class="et27-dot" style="background: #d4a017"></span> Líder
      </div>
      <div class="row">
        <span class="et27-dot" style="background: #d9534f"></span> Adversario
      </div>
      <div class="row">
        <span class="et27-dot" style="background: #1f77b4"></span> Rep. Casilla
      </div>
      <div class="row">
        <span class="et27-dot" style="background: #6f42c1"></span> Rep. General
      </div>
      <div class="row">
        <span class="et27-dot" style="background: #2aa198"></span> Observador
      </div>
      <hr style="margin: 8px 0; border: none; border-top: 1px solid #f1f5f9" />
      <h4>Casillas (cobertura)</h4>
      <div class="row">
        <span class="et27-dot" style="background: #2ca02c"></span> Cubierta
      </div>
      <div class="row">
        <span class="et27-dot" style="background: #ffbf00"></span> Parcial
      </div>
      <div class="row">
        <span class="et27-dot" style="background: #d62728"></span> Sin cobertura
      </div>
    </div>

    <!-- ET-27: Panel de Faltantes -->
    <div class="et27-panel" id="et27-panel">
      <header>
        <div class="ttl">Faltantes de Cobertura</div>
        <div class="act">
          <button class="et27-btn" id="et27-export-csv">Exportar CSV</button>
          <button class="et27-btn" id="et27-close-panel">Cerrar</button>
        </div>
      </header>
      <div style="padding: 8px 12px">
        <table class="et27-table" id="et27-table">
          <thead>
            <tr>
              <th>Ámbito</th>
              <th>Clave</th>
              <th>Casillas</th>
              <th>Req.Rep</th>
              <th>Asig.Rep</th>
              <th>Faltan</th>
              <th>Estatus</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>

    <!-- === SCRIPT ÚNICO === -->
    <script>
      // ===== 0) Campos (ajusta si tus nombres son distintos) =====
      // DL = Distrito Local, DF = Distrito Federal
      const FIELD_KEYS = {
        mun: "MUNICIPIO",
        dl: "DISTRITO_L",
        df: "DISTRITO_F",
      };

      const paths = JSON.parse(localStorage.getItem("AT_PATHS") || "{}");
      const urlGeo = paths.geo || "data/geo/secciones.geojson";
      const catUrl = paths.catalog || "data/catalogo_territorial.json";
      const ELP = paths.electoral?.P || "data/electoral/P.json";
      // ...

      // ===== 1) Mapa único y chequeo =====
      function ensureLeafletMap() {
        if (window.__AT_MAP && window.__AT_MAP instanceof L.Map)
          return window.__AT_MAP;
        const m = L.map("map", { zoomControl: true }).setView(
          [21.0, -101.3],
          7
        );
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "© OSM",
        }).addTo(m);
        window.__AT_MAP = m;
        return m;
      }
      function assertIsLeafletMap(m) {
        if (!(m instanceof L.Map) || typeof m.addLayer !== "function") {
          throw new Error(
            '[AT] addTo(): destino no es un Leaflet Map. Revisa variables llamadas "map" o dobles inicializaciones.'
          );
        }
      }

      function closeSecInfoPanel() {
        const box = document.getElementById("sec-info");
        if (box) box.style.display = "none";
        // Si quieres limpiar resaltado y etiquetas al cerrar:
        if (typeof clearSectionOverlays === "function") clearSectionOverlays();
      }

      function ensureSecInfoPanelWired() {
        const box = document.getElementById("sec-info");
        const hdr = box?.querySelector(".hdr");
        if (!box || !hdr || box.__wired) return;

        // Bloquear propagación al mapa (no “parpadea” al arrastrar)
        if (window.L && L.DomEvent) {
          L.DomEvent.disableClickPropagation(box);
          L.DomEvent.disableScrollPropagation(box);
        }

        // Drag del panel
        let dragging = false,
          sx = 0,
          sy = 0,
          bx = 0,
          by = 0;
        hdr.addEventListener("mousedown", (e) => {
          if (e.target.closest(".btn-close")) return; // no iniciar drag si clic en "×"
          e.preventDefault();
          e.stopPropagation();
          dragging = true;
          const r = box.getBoundingClientRect();
          sx = e.clientX;
          sy = e.clientY;
          bx = r.left;
          by = r.top;
          box.style.position = "absolute";
          box.style.right = "auto";
          box.style.bottom = "auto";
          document.body.style.userSelect = "none";
        });
        window.addEventListener("mousemove", (e) => {
          if (!dragging) return;
          e.preventDefault();
          e.stopPropagation();
          const dx = e.clientX - sx,
            dy = e.clientY - sy;
          box.style.left = bx + dx + "px";
          box.style.top = by + dy + "px";
        });
        window.addEventListener("mouseup", () => {
          if (!dragging) return;
          dragging = false;
          document.body.style.userSelect = "";
        });

        // Botón “×”
        const btn = document.getElementById("sec-close");
        if (btn && !btn.__wired) {
          btn.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeSecInfoPanel();
          });
          btn.__wired = true;
        }

        box.__wired = true;
      }

      // ===== 2) Filtrado por universo =====
      function toComp(v) {
        if (v == null) return "";
        const s = String(v).trim();
        return isFinite(s) && s !== "" ? Number(s) : s.toUpperCase();
      }
      function matches(props, u) {
        if (u.scope === "ALL") return true;
        const keyField =
          u.scope === "MUN"
            ? FIELD_KEYS.mun
            : u.scope === "DL"
            ? FIELD_KEYS.dl
            : FIELD_KEYS.df;
        return toComp(props?.[keyField]) === toComp(u.key);
      }
      function filterGeojson(geojson, u) {
        if (u.scope === "ALL") return geojson;
        const features = (geojson.features || []).filter((f) =>
          matches(f.properties, u)
        );
        return { ...geojson, features };
      }

      // ====== CARGA ELECTORAL (para obtener 24DL_LN) ======
      function getPaths() {
        try {
          return JSON.parse(localStorage.getItem("AT_PATHS") || "{}");
        } catch {
          return {};
        }
      }
      function getPuestoPath(p) {
        const paths = getPaths();
        return paths?.electoral?.[p] || `data/electoral/${p}.json`;
      }

      window.AT_ELECT = window.AT_ELECT || {};
      async function getElectData(puesto) {
        if (window.AT_ELECT[puesto]) return window.AT_ELECT[puesto];
        const res = await fetch(getPuestoPath(puesto));
        if (!res.ok) throw new Error(`HTTP ${res.status} en ${puesto}`);
        const js = await res.json();
        window.AT_ELECT[puesto] = js;
        return js;
      }
      // LN para 2024 desde DL; si no hay, intenta P (fallback)
      async function getLN24DL(sec) {
        const key = String(sec);
        try {
          const dl = await getElectData("DL");
          const ln = dl?.secciones?.[key]?.["2024"]?.LN;
          if (typeof ln === "number") return ln;
        } catch (_) {}
        try {
          const p = await getElectData("P");
          const ln = p?.secciones?.[key]?.["2024"]?.LN;
          if (typeof ln === "number") return ln;
        } catch (_) {}
        return null;
      }

      // ====== ADYACENCIAS (Turf) ======
      function bboxIntersects(b1, b2) {
        return !(
          b2[0] > b1[2] ||
          b2[2] < b1[0] ||
          b2[1] > b1[3] ||
          b2[3] < b1[1]
        );
      }
      function getAdjacents(feat) {
        const all =
          window.AT_DATA?.features ||
          window.AT_CTX?.layer?.toGeoJSON?.()?.features ||
          [];
        if (!all.length) return [];
        const b1 = turf.bbox(feat);
        const out = [];
        const sec1 = feat.properties?.SECCION;
        for (const f of all) {
          const p = f.properties || {};
          if (p.SECCION === sec1) continue;
          const b2 = turf.bbox(f);
          if (!bboxIntersects(b1, b2)) continue;
          try {
            if (
              turf.booleanTouches(feat, f) ||
              turf.booleanOverlap(feat, f) ||
              turf.booleanIntersects(feat, f)
            ) {
              out.push(f);
            }
          } catch (_) {}
        }
        return out.slice(0, 25); // cota de seguridad
      }

      // ====== LABELS SOBRE EL MAPA ======
      function addLabelForFeature(feat, className, text) {
        try {
          const c = turf.centerOfMass(feat).geometry.coordinates; // [lon, lat]
          const m = L.marker([c[1], c[0]], {
            icon: L.divIcon({ className, html: text, iconSize: [0, 0] }),
          });
          window.__SEC_LABELS =
            window.__SEC_LABELS || L.layerGroup().addTo(ensureLeafletMap());
          window.__SEC_LABELS.addLayer(m);
          return m;
        } catch (_) {}
        return null;
      }

      function clearSectionOverlays() {
        const atMap = ensureLeafletMap();
        if (window.__SEC_HL) {
          try {
            atMap.removeLayer(__SEC_HL);
          } catch (_) {}
          window.__SEC_HL = null;
        }
        if (window.__SEC_ADJ) {
          try {
            atMap.removeLayer(__SEC_ADJ);
          } catch (_) {}
          window.__SEC_ADJ = null;
        }
        if (window.__SEC_LABELS) {
          try {
            atMap.removeLayer(__SEC_LABELS);
          } catch (_) {}
          window.__SEC_LABELS = null;
        }
      }

      // Dibuja selección + adyacentes + labels
      function paintSelectionAndAdj(feat) {
        const atMap = ensureLeafletMap();
        clearSectionOverlays();

        // resaltado principal
        window.__SEC_HL = L.geoJSON(feat, {
          style: { color: "#e91e63", weight: 3, fillOpacity: 0.25 },
        }).addTo(atMap);
        try {
          atMap.fitBounds(window.__SEC_HL.getBounds(), { padding: [28, 28] });
        } catch (_) {}

        // adyacentes
        const adj = getAdjacents(feat);
        if (adj.length) {
          window.__SEC_ADJ = L.geoJSON(
            { type: "FeatureCollection", features: adj },
            {
              style: {
                color: "#90a4ae",
                weight: 1.2,
                dashArray: "4,4",
                fillOpacity: 0.05,
              },
            }
          ).addTo(atMap);
        }

        // labels
        const sec = feat.properties?.SECCION ?? "—";
        addLabelForFeature(feat, "sec-label", `Sección ${sec}`);
        for (const f of adj) {
          const s2 = f.properties?.SECCION ?? "—";
          addLabelForFeature(f, "sec-label-adj", s2);
        }
      }

      // ====== PANEL FLOTANTE (drag + datos) ======
      (function wireSecInfoPanel() {
        const box = document.getElementById("sec-info");
        const hdr = box?.querySelector(".hdr");
        if (!box || !hdr || box.__wired) return;
        let dragging = false,
          sx = 0,
          sy = 0,
          bx = 0,
          by = 0;
        hdr.addEventListener("mousedown", (e) => {
          dragging = true;
          sx = e.clientX;
          sy = e.clientY;
          const r = box.getBoundingClientRect();
          bx = r.left;
          by = r.top;
          document.body.style.userSelect = "none";
        });
        window.addEventListener("mousemove", (e) => {
          if (!dragging) return;
          const dx = e.clientX - sx,
            dy = e.clientY - sy;
          box.style.left = bx + dx + "px";
          box.style.top = by + dy + "px";
          box.style.right = "auto";
          box.style.bottom = "auto";
          box.style.position = "absolute";
        });
        window.addEventListener("mouseup", () => {
          dragging = false;
          document.body.style.userSelect = "";
        });
        box.__wired = true;
      })();

      async function showSectionInfo(feat) {
        ensureSecInfoPanelWired();
        const p = feat.properties || {};
        const sec = p.SECCION ?? "—";
        const df = p[FIELD_KEYS.df] ?? "—";
        const dl = p[FIELD_KEYS.dl] ?? "—";

        // LN 24DL_LN
        let ln = await getLN24DL(sec);
        if (ln == null) ln = "—";

        // Pintar
        const box = document.getElementById("sec-info");
        box.querySelector(".hdr").textContent = `Sección ${sec}`;
        document.getElementById("si-sec").textContent = sec;
        document.getElementById("si-df").textContent = df;
        document.getElementById("si-dl").textContent = dl;
        document.getElementById("si-ln").textContent = ln;
        box.style.display = "block";
      }

      // ENTER + CLIC + ULTIMO TOKEN

      function currentNeedle(q) {
        if (!q) return "";
        const parts = String(q)
          .split(/[,;\s]+/)
          .filter(Boolean);
        return parts.length ? parts[parts.length - 1] : "";
      }

      // ===== Mini-selector de universo dentro del módulo =====
      let __mini = { selMun: null, selDf: null, selDl: null, all: null };

      function uniqueSorted(values) {
        const arr = values.map((v) => String(v ?? "").trim()).filter(Boolean);
        const set = Array.from(new Set(arr));
        return set.sort((a, b) =>
          isFinite(a) && isFinite(b)
            ? Number(a) - Number(b)
            : a.localeCompare(b, "es")
        );
      }
      function buildMiniOptions(raw) {
        const feats = raw.features || [];
        const grab = (k) => uniqueSorted(feats.map((f) => f.properties?.[k]));
        return {
          mun: grab(FIELD_KEYS.mun),
          df: grab(FIELD_KEYS.df),
          dl: grab(FIELD_KEYS.dl),
        };
      }
      function fillSelect(sel, arr) {
        sel.innerHTML =
          '<option value="">— Ninguno —</option>' +
          arr.map((v) => `<option value="${v}">${v}</option>`).join("");
      }
      function getMiniUniverse() {
        const { selMun, selDf, selDl, all } = __mini;
        if (all.checked)
          return { scope: "ALL", key: null, label: "Estado completo" };
        if (selMun.value)
          return {
            scope: "MUN",
            key: selMun.value,
            label: `Municipio ${selMun.options[selMun.selectedIndex].text}`,
          };
        if (selDf.value)
          return {
            scope: "DF",
            key: selDf.value,
            label: `Distrito Federal ${selDf.value}`,
          };
        if (selDl.value)
          return {
            scope: "DL",
            key: selDl.value,
            label: `Distrito Local ${selDl.value}`,
          };
        return null;
      }
      function miniExclusivity(which) {
        const { selMun, selDf, selDl, all } = __mini;
        if (which === "ALL") {
          selMun.value = "";
          selDf.value = "";
          selDl.value = "";
        }
        if (which === "MUN") {
          selDf.value = "";
          selDl.value = "";
          all.checked = false;
        }
        if (which === "DF") {
          selMun.value = "";
          selDl.value = "";
          all.checked = false;
        }
        if (which === "DL") {
          selMun.value = "";
          selDf.value = "";
          all.checked = false;
        }
        applyMiniUniverse();
      }
      function applyMiniUniverse() {
        const u2 = getMiniUniverse();
        if (!u2) return;
        // 1) Persistir
        localStorage.setItem(
          "AT_UNIVERSE",
          JSON.stringify({ ...u2, ts: Date.now() })
        );
        // 2) Redibujar con el nuevo universo usando el raw ya cargado
        const atMap = ensureLeafletMap();
        const filtered2 = filterGeojson(window.AT_DATA, u2);
        if (window.AT_CTX?.layer) {
          atMap.removeLayer(AT_CTX.layer);
        }
        const layer2 = L.geoJSON(filtered2, {
          style: { color: "#7d0025", weight: 1.2, fillOpacity: 0.15 },
        }).addTo(atMap);
        try {
          atMap.fitBounds(layer2.getBounds(), { padding: [20, 20] });
        } catch (e) {}
        window.AT_CTX = {
          ...(window.AT_CTX || {}),
          universe: u2,
          layer: layer2,
        };
        // 3) Header
        const hdr = document.querySelector("#panel-header span");
        if (hdr) {
          hdr.textContent = `Análisis Territorial · ${u2.label}`;
        }
        refreshSectionSearch(u2);
      }
      function initMiniSelector(raw, u) {
        // Guardar el geojson bruto para futuros re-filtros
        window.AT_DATA = raw;

        __mini.selMun = document.getElementById("mini-sel-mun");
        labelMunicipiosFromCatalog("#mini-sel-mun");

        __mini.selDf = document.getElementById("mini-sel-df");
        __mini.selDl = document.getElementById("mini-sel-dl");
        __mini.all = document.getElementById("mini-all-state");

        const opt = buildMiniOptions(raw);
        fillSelect(__mini.selMun, opt.mun);
        fillSelect(__mini.selDf, opt.df);
        fillSelect(__mini.selDl, opt.dl);

        // Reflejar el universo actual
        if (u.scope === "ALL") {
          __mini.all.checked = true;
        }
        if (u.scope === "MUN") {
          __mini.selMun.value = String(u.key);
        }
        if (u.scope === "DF") {
          __mini.selDf.value = String(u.key);
        }
        if (u.scope === "DL") {
          __mini.selDl.value = String(u.key);
        }

        async function labelMunicipiosFromCatalog(selectId) {
          const sel = document.querySelector(selectId);
          if (!sel) return;

          // 1) Ruta del catálogo desde el Portal (AT_PATHS) o fallback
          let catUrl = "data/catalogo_territorial.json";
          try {
            const paths = JSON.parse(localStorage.getItem("AT_PATHS") || "{}");
            if (paths?.catalog) catUrl = paths.catalog;
          } catch {}

          // 2) Cargar catálogo
          let cat = null;
          try {
            const r = await fetch(catUrl);
            if (!r.ok) throw new Error("HTTP " + r.status);
            cat = await r.json();
          } catch (e) {
            console.warn("[AT] No se pudo cargar el catálogo:", e);
            return; // salimos sin tocar etiquetas
          }

          const mapa = cat?.municipios || {};
          // helper: si el catálogo trae ceros a la izquierda en las llaves
          const getName = (code) => {
            const s = String(code);
            return (
              mapa[s] ||
              mapa[s.padStart(2, "0")] ||
              mapa[s.padStart(3, "0")] ||
              s
            );
          };

          // 3) Reetiquetar opciones (sin cambiar value)
          for (const opt of sel.options) {
            if (!opt.value) continue; // deja "— Ninguno —"
            const name = getName(opt.value);
            opt.text = `${opt.value} — ${name}`;
          }
        }

        // Eventos (auto-ejecuta)
        __mini.selMun.addEventListener("change", () => miniExclusivity("MUN"));
        __mini.selDf.addEventListener("change", () => miniExclusivity("DF"));
        __mini.selDl.addEventListener("change", () => miniExclusivity("DL"));
        __mini.all.addEventListener("change", () => miniExclusivity("ALL"));
      }

      // Nombre fijo del campo (texto) del municipio
      const MUN_NAME_KEY = "MUNICIPIO";

      // Detecta automáticamente el campo de CÓDIGO de municipio (si no, usa el nombre)
      function detectMunCodeKey(raw) {
        const feats = raw.features || [];
        const candidates = [
          "MUN",
          "CVE_MUN",
          "CLV_MUN",
          "ID_MUN",
          "MUNICIPIO_ID",
          "MUNICIPIO_CVE",
          "CVE_MUNICIPIO",
          "CVE_MPIO",
        ];
        for (const k of candidates) {
          const ok = feats.some((f) => {
            const v = f.properties?.[k];
            return (
              v != null &&
              String(v).trim() !== "" &&
              String(v).toUpperCase() !== "NULL"
            );
          });
          if (ok) return k;
        }
        return null; // fallback será MUN_NAME_KEY
      }

      // —— Utils de texto ——
      function _norm(s) {
        if (s == null) return "";
        return String(s)
          .normalize("NFD")
          .replace(/[\u0300-\u036f]/g, "")
          .toUpperCase()
          .trim();
      }
      function _isDigits(s) {
        return /^[0-9]+$/.test(String(s || ""));
      }

      // —— Nombre de municipio desde catálogo (si existe) ——
      function getMunNameFromCatalog(code) {
        const cat = window.AT_CATALOG;
        if (!cat?.municipios) return String(code ?? "");
        const s = String(code);
        // maneja posibles ceros a la izquierda
        return (
          cat.municipios[s] ||
          cat.municipios[s.padStart(2, "0")] ||
          cat.municipios[s.padStart(3, "0")] ||
          s
        );
      }

      // —— Índice de secciones ——
      let __SEC_INDEX = { items: [], global: false };

      function buildSectionIndex(raw, universe, useGlobal) {
        const feats = raw?.features || [];
        const munKey = window.AT_KEYS?.munCode || FIELD_KEYS.mun;
        const items = [];

        // dataset base: global = todas, local = filtradas por universo
        const base = useGlobal
          ? feats
          : filterGeojson(raw, universe).features || [];

        for (const f of base) {
          const p = f.properties || {};
          const sec = p.SECCION ?? p.Seccion ?? p.seccion ?? null;
          if (sec == null) continue;

          const munCode = p[munKey];
          const munName = getMunNameFromCatalog(munCode);
          const df = p[FIELD_KEYS.df];
          const dl = p[FIELD_KEYS.dl];

          // texto para búsqueda
          const text = `${sec} ${munCode ?? ""} ${munName ?? ""} ${df ?? ""} ${
            dl ?? ""
          }`;
          // bounds (si multiparte, Leaflet lo resuelve)
          let bounds = null;
          try {
            bounds = L.geoJSON(f).getBounds();
          } catch (_) {}

          items.push({
            sec: String(sec).trim(),
            munCode: munCode,
            munName: munName,
            df,
            dl,
            feature: f,
            textNorm: _norm(text),
            bounds,
          });
        }

        __SEC_INDEX = { items, global: !!useGlobal };
      }

      function searchSections(query, limit = 15) {
        const q = _norm(query);
        if (!q) return [];
        const ds = __SEC_INDEX.items;

        // Heurística sencilla:
        // - si es numérico puro: prioridad a SECCION que empiece con q
        // - si no: contiene tokens
        if (_isDigits(q)) {
          const starts = ds.filter((it) => _norm(it.sec).startsWith(q));
          if (starts.length >= limit) return starts.slice(0, limit);
          const contains = ds.filter((it) => _norm(it.sec).includes(q));
          return [...starts, ...contains].slice(0, limit);
        } else {
          const tokens = q.split(/\s+/).filter(Boolean);
          return ds
            .filter((it) => tokens.every((t) => it.textNorm.includes(t)))
            .slice(0, limit);
        }
      }

      // —— UI de sugerencias ——
      let __SEC_HIGHLIGHT = null;

      function renderSecSuggestions(list) {
        const ul = document.getElementById("sec-suggest");
        if (!ul) return;
        if (!list.length) {
          ul.style.display = "none";
          ul.innerHTML = "";
          return;
        }

        ul.innerHTML = list
          .map((it) => {
            const label = `${it.sec} — ${
              it.munName || it.munCode || ""
            }`.replace(/\s+-\s+$/, "");
            const meta = [];
            if (it.dl != null) meta.push(`DL ${it.dl}`);
            if (it.df != null) meta.push(`DF ${it.df}`);
            const sub = meta.length
              ? `<small style="color:#64748b">${meta.join(" · ")}</small>`
              : "";
            return `<li data-sec="${it.sec}" style="padding:6px 8px; border-bottom:1px solid #e5e7eb; cursor:pointer">
                    <div>${label}</div>${sub}
                  </li>`;
          })
          .join("");
        ul.style.display = "block";
      }

      function gotoSection(item) {
        const atMap = window.AT_CTX?.map || ensureLeafletMap();

        // 1) Resolver el feature de la sección
        const sec = String(item.sec ?? item.SECCION ?? "");
        let feat = item.feature;

        if (!feat) {
          const feats =
            window.AT_CTX?.layer?.toGeoJSON?.().features ||
            window.AT_DATA?.features ||
            [];
          feat = feats.find((f) => String(f.properties?.SECCION) === sec);
        }

        if (!feat) {
          console.warn(
            "[AT] No encontré el feature para la sección",
            sec,
            item
          );
          return;
        }

        // 2) Pintar selección + adyacentes + labels (esto limpia overlays previos)
        paintSelectionAndAdj(feat);

        // 3) Mostrar panel con DF, DL y LN (24DL_LN)
        showSectionInfo(feat);

        // 4) Feedback visual (parpadeo leve sobre el highlight actual)
        const hl = window.__SEC_HL;
        if (hl && typeof hl.setStyle === "function") {
          try {
            hl.setStyle({ weight: 4 });
            setTimeout(() => {
              try {
                hl.setStyle({ weight: 3 });
              } catch (_) {}
            }, 220);
          } catch (_) {}
        }

        // 5) Oculta la lista de sugerencias (si está visible)
        const ul = document.getElementById("sec-suggest");
        if (ul) ul.style.display = "none";
      }

      // Delegación de clic en las sugerencias (una sola vez)
      (function wireSectionSearchEventsOnce() {
        const ul = document.getElementById("sec-suggest");
        const input = document.getElementById("sec-q");
        if (!ul || !input) return;

        // Si está dentro de un form, evita submit al Enter
        const form = input.closest("form");
        form?.addEventListener("submit", (e) => e.preventDefault());

        // Clic en cualquier <li data-sec="...">
        if (!ul.__wiredClick) {
          ul.addEventListener("click", (ev) => {
            const li = ev.target.closest("li[data-sec]");
            if (!li) return;
            const sec = li.getAttribute("data-sec");
            const item = (__SEC_INDEX?.items || []).find(
              (x) => String(x.sec) === String(sec)
            );
            if (item) gotoSection(item);
            ul.style.display = "none";
          });
          ul.__wiredClick = true;
        }

        // Enter en el input = ir al primer resultado
        if (!input.__wiredKey) {
          input.addEventListener("keydown", (ev) => {
            if (ev.key === "Enter") {
              ev.preventDefault(); // <- evita submit/autocomplete
              const results = searchSections(input.value, 1);
              const needle = currentNeedle(input.value);
              const [first] = searchSections(needle, 1);
              if (first) gotoSection(first);
              ul.style.display = "none";
            }
            if (ev.key === "Escape") {
              ul.style.display = "none";
            }
          });
          input.__wiredKey = true;
        }

        // Input: recalcula sugerencias usando el "último token"
        if (!input.__wiredInput) {
          input.addEventListener("input", () => {
            const needle = currentNeedle(input.value);
            renderSecSuggestions(searchSections(needle, 15));
          });
          input.__wiredInput = true;
        }
      })();

      // —— Inicializar Buscador en el módulo ——
      function initSectionSearch(raw, universe) {
        const input = document.getElementById("sec-q");
        const list = document.getElementById("sec-suggest");
        const globalC = document.getElementById("sec-global");
        if (!input || !list) return;

        // construir índice (por universo actual)
        buildSectionIndex(raw, universe, !!globalC?.checked);

        // Cambiar ámbito (global / universo actual)
        globalC?.addEventListener("change", () => {
          buildSectionIndex(raw, universe, !!globalC.checked);
          // refresca sugerencias con la query actual
          if (input.value) {
            renderSecSuggestions(searchSections(input.value, 15));
          }
        });
      }

      // —— Cuando cambies de universo con tu mini-selector, reindexa ——
      function refreshSectionSearch(universe) {
        const input = document.getElementById("sec-q");
        const globalC = document.getElementById("sec-global");
        if (!window.AT_DATA || !input) return;
        buildSectionIndex(window.AT_DATA, universe, !!globalC?.checked);
        if (input.value) {
          renderSecSuggestions(searchSections(input.value, 15));
        }
      }

      function getRawForIndex() {
        // Usa el dataset completo si ya lo cacheaste
        if (window.AT_DATA) return window.AT_DATA;
        // Si no, al menos usa lo ya pintado en el mapa
        const lyr = window.AT_CTX?.layer;
        return lyr && typeof lyr.toGeoJSON === "function"
          ? lyr.toGeoJSON()
          : null;
      }

      // ===== 3) Boot =====
      document.addEventListener("DOMContentLoaded", async () => {
        // a) Leer universo y rutas puestos en el PORTAL
        const u = JSON.parse(localStorage.getItem("AT_UNIVERSE") || "null");
        const paths = JSON.parse(
          localStorage.getItem("AT_PATHS") || '{"geo":""}'
        );
        if (!u) {
          const hdr = document.querySelector("#panel-header span");
          hdr && (hdr.textContent += " · selecciona el universo en el Portal");
          setTimeout(() => {
            location.href = "portal.html";
          }, 600);
          return;
        }

        // b) Etiqueta del universo
        const hdr = document.querySelector("#panel-header span");
        hdr && (hdr.textContent += ` · ${u.label}`);

        // c) Mapa único
        const atMap = ensureLeafletMap();
        assertIsLeafletMap(atMap);

        // d) Cargar y filtrar GeoJSON
        const url = paths.geo || "data/geo/secciones.geojson"; // <-- ajusta si tu ruta difiere

        // Cargar catálogo territorial (para nombres visibles)
        const catUrl =
          (paths.catalog && paths.catalog.trim()) ||
          "/data/catalogo_territorial.json";
        let catalog = window.AT_CATALOG || null;
        if (!catalog) {
          try {
            const rc = await fetch(catUrl);
            if (!rc.ok)
              throw new Error(`HTTP ${rc.status} al cargar catálogo ${catUrl}`);
            catalog = await rc.json();
            window.AT_CATALOG = catalog;
          } catch (err) {
            console.warn("[AT] No se pudo cargar el catálogo de nombres:", err);
            window.AT_CATALOG = catalog = null; // seguimos sin nombres amigables
          }
        }

        let raw = window.AT_DATA || null; // usa caché si ya existe
        if (!raw) {
          try {
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
            raw = await res.json(); // ✅ solo una vez
            window.AT_DATA = raw; // ✅ guarda en caché aquí
          } catch (err) {
            console.error("[AT] Error cargando GeoJSON:", err);
            alert("No se pudo cargar el GeoJSON");
            return;
          }
        }
        // a partir de aquí, usa 'raw'

        const filtered = filterGeojson(raw, u);
        console.log(
          "[AT] Universo:",
          u,
          "Total:",
          raw.features?.length || 0,
          "Filtradas:",
          filtered.features?.length || 0
        );

        if (!filtered.features || filtered.features.length === 0) {
          console.warn(
            "[AT] No hay geometrías para el universo seleccionado:",
            u
          );
          alert("No hay datos para el universo seleccionado");
        }

        // Nombre fijo del campo (texto) del municipio
        const MUN_NAME_KEY = "MUNICIPIO";

        // Detecta campo de CÓDIGO (si existe); si no, usa el de nombre
        function detectMunCodeKey(raw) {
          const feats = raw.features || [];
          const candidates = [
            "MUN",
            "CVE_MUN",
            "CLV_MUN",
            "ID_MUN",
            "MUNICIPIO_ID",
            "MUNICIPIO_CVE",
            "CVE_MUNICIPIO",
            "CVE_MPIO",
          ];
          for (const k of candidates) {
            if (feats.some((f) => (f.properties?.[k] ?? "") !== "")) return k;
          }
          return null;
        }

        const munCodeKey = detectMunCodeKey(raw) || MUN_NAME_KEY; // fallback: nombre
        FIELD_KEYS.mun = munCodeKey;
        window.AT_KEYS = { munCode: munCodeKey, munName: MUN_NAME_KEY };

        // e) Dibujar capa
        const layer = L.geoJSON(filtered, {
          style: { color: "#000000", weight: 1.2, fillOpacity: 0.15 },
          onEachFeature: (feat, lyr) => {
            const p = feat.properties || {};
            const muni = p[FIELD_KEYS.mun] ?? "—";
            const dl = p[FIELD_KEYS.dl] ?? "—";
            const df = p[FIELD_KEYS.df] ?? "—";
            lyr.bindPopup(
              `<b>Sección</b>: ${
                p.SECCION ?? "—"
              }<br><b>Mun</b>: ${muni}<br><b>DL</b>: ${dl}<br><b>DF</b>: ${df}`
            );
            lyr.on("mouseover", () => lyr.setStyle({ weight: 2 }));
            lyr.on("mouseout", () => lyr.setStyle({ weight: 1.2 }));
          },
        }).addTo(atMap);

        try {
          atMap.fitBounds(layer.getBounds(), { padding: [20, 20] });
        } catch (e) {}
        window.AT_CTX = { universe: u, paths, map: atMap, layer };

        function getMunNameFromCatalog(code) {
          const cat = window.AT_CATALOG;
          if (!cat?.municipios) return String(code ?? "");
          return cat.municipios[String(code)] || String(code ?? "");
        }
        function getDfListFromCatalog(feats) {
          return window.AT_CATALOG?.distritos_federales &&
            window.AT_CATALOG.distritos_federales.length
            ? window.AT_CATALOG.distritos_federales
            : uniqSorted(feats.map((f) => f.properties?.[FIELD_KEYS.df]));
        }
        function getDlListFromCatalog(feats) {
          return window.AT_CATALOG?.distritos_locales &&
            window.AT_CATALOG.distritos_locales.length
            ? window.AT_CATALOG.distritos_locales
            : uniqSorted(feats.map((f) => f.properties?.[FIELD_KEYS.dl]));
        }
        initMiniSelector(raw, u);
        initSectionSearch(window.AT_DATA || raw, u);
      });

      (function wireATHotkeys() {
        if (window.__AT_HOTKEYS) return;
        window.__AT_HOTKEYS = true;

        window.addEventListener("keydown", (e) => {
          // Esc: cerrar panel
          if (e.key === "Escape") {
            if (document.getElementById("sec-info")?.style.display !== "none") {
              e.preventDefault();
              closeSecInfoPanel();
            }
          }
          // Ctrl+K (o Cmd+K en Mac): enfocar buscador de secciones
          if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "k") {
            e.preventDefault();
            document.getElementById("sec-q")?.focus();
          }
        });
      })();
    </script>
    <div id="sec-info">
      <div class="hdr">
        <span class="ttl">Sección</span>
        <button id="sec-close" class="btn-close" aria-label="Cerrar">×</button>
      </div>
      <div class="body">
        <div class="row">
          <span class="k">Sección</span> <span class="v" id="si-sec">—</span>
        </div>
        <div class="row">
          <span class="k">Distrito Federal</span
          ><span class="v" id="si-df">—</span>
        </div>
        <div class="row">
          <span class="k">Distrito Local</span>
          <span class="v" id="si-dl">—</span>
        </div>
        <div class="row">
          <span class="k">LN (2024)</span> <span class="v" id="si-ln">—</span>
        </div>
      </div>
    </div>

    <script>
      /* ===== ET-27 core ===== */
      const ET27_CFG = {
        get paths() {
          const p = JSON.parse(localStorage.getItem("AT_PATHS") || "{}");
          const et = p.et27 || {};
          return {
            puntos: et.puntos || "estrategico/data/puntos_campo.geojson",
            casillas: et.casillas || "estrategico/data/casillas.geojson",
            secciones: p.geo || "estrategico/geojson/secciones.geojson",
          };
        },
        rolesColor: {
          SIMPATIZANTE: "#6CAB5A",
          LIDER: "#D4A017",
          ADVERSARIO: "#D9534F",
          REP_CASILLA: "#1F77B4",
          REP_GENERAL: "#6F42C1",
          OBSERVADOR: "#2AA198",
        },
        cobertura: {
          rep_por_casilla: 2,
          obs_por_casilla: 0,
          rep_general_por_seccion: 1,
        },
      };

      const ET27 = {
        map: null,
        grpPoints: null,
        grpCasillas: null,
        grpSecCover: null,
        data: { puntos: null, casillas: null, secciones: null },
        faltantes: [],

        ensureMap() {
          if (!this.map) {
            if (typeof ensureLeafletMap === "function")
              this.map = ensureLeafletMap();
            else this.map = L.map("map").setView([21.12, -101.68], 10);
          }
          return this.map;
        },

        async loadAll() {
          const { puntos, casillas, secciones } = ET27_CFG.paths;
          const fetchJSON = async (u) => {
            const r = await fetch(u);
            if (!r.ok) throw new Error(`HTTP ${r.status} en ${u}`);
            return r.json();
          };

          const [pts, cas, secc] = await Promise.allSettled([
            fetchJSON(puntos),
            fetchJSON(casillas),
            window.AT_CTX?.layer
              ? Promise.resolve(window.AT_CTX.layer.toGeoJSON())
              : fetchJSON(secciones),
          ]);

          this.data.puntos =
            pts.status === "fulfilled"
              ? pts.value
              : { type: "FeatureCollection", features: [] };
          this.data.casillas =
            cas.status === "fulfilled"
              ? cas.value
              : { type: "FeatureCollection", features: [] };
          this.data.secciones =
            secc.status === "fulfilled"
              ? secc.value
              : { type: "FeatureCollection", features: [] };

          // Si hay universo activo en tu app, filtramos a ese universo
          const u = window.AT_CTX?.universe;
          if (u) {
            const keyMap = {
              MUN: "MUNICIPIO",
              DF: "DISTRITO_F",
              DL: "DISTRITO_L",
            };
            const fk = keyMap[u.scope];
            if (fk) {
              const k = String(u.key);
              const by = (fc, kfield) => ({
                type: "FeatureCollection",
                features: (fc.features || []).filter(
                  (f) => String(f.properties?.[kfield] ?? "") === k
                ),
              });
              this.data.puntos = by(this.data.puntos, fk);
              this.data.casillas = by(this.data.casillas, fk);
              if (!window.AT_CTX?.layer) {
                this.data.secciones = by(this.data.secciones, fk);
              }
            }
          }

          this.paintPoints();
          this.paintCasillas();
          this.updateKPIs();
          document.getElementById("et27-kpis").style.display = "flex";
          document.getElementById("et27-legend").style.display = "block";
        },

        paintPoints() {
          const m = this.ensureMap();
          if (this.grpPoints) {
            try {
              m.removeLayer(this.grpPoints);
            } catch (_) {}
            this.grpPoints = null;
          }

          const cluster = L.markerClusterGroup({
            disableClusteringAtZoom: 15,
            spiderfyOnMaxZoom: true,
          });
          (this.data.puntos.features || []).forEach((f) => {
            const p = f.properties || {},
              c = f.geometry?.coordinates;
            if (!c) return;
            const role = String(p.TIPO || "").toUpperCase();
            const color = ET27_CFG.rolesColor[role] || "#111827";
            const icon = L.divIcon({
              className: "et27-role-dot",
              html: `<span style="display:inline-block;width:10px;height:10px;border-radius:50%;background:${color};border:1px solid #11182722"></span>`,
              iconSize: [10, 10],
            });
            const mk = L.marker([c[1], c[0]], { icon });
            mk.bindPopup(`<div style="min-width:220px">
        <div style="font-weight:700">${p.NOMBRE || "—"}</div>
        <div><b>Tipo:</b> ${role}</div>
        <div><b>Sección:</b> ${p.SECCION ?? "—"}</div>
        <div><b>Municipio:</b> ${p.MUNICIPIO_NOMBRE ?? p.MUNICIPIO ?? "—"}</div>
        <div><b>Tel:</b> ${p.TELEFONO ?? "—"}</div>
        ${p.CASILLA_ID ? `<div><b>Casilla:</b> ${p.CASILLA_ID}</div>` : ""}
        ${p.PROMOTOR_PIN ? `<div><b>Promotor:</b> ${p.PROMOTOR_PIN}</div>` : ""}
        <div style="font-size:11px;color:#64748b">${p.ESTATUS ?? "ACTIVO"}</div>
      </div>`);
            cluster.addLayer(mk);
          });
          this.grpPoints = cluster.addTo(m);
        },

        paintCasillas() {
          const m = this.ensureMap();
          if (this.grpCasillas) {
            try {
              m.removeLayer(this.grpCasillas);
            } catch (_) {}
            this.grpCasillas = null;
          }

          const g = L.layerGroup();
          const req = ET27_CFG.cobertura.rep_por_casilla;

          const repsByCasilla = {};
          (this.data.puntos.features || []).forEach((f) => {
            const p = f.properties || {};
            if (String(p.TIPO || "").toUpperCase() !== "REP_CASILLA") return;
            const id = p.CASILLA_ID || null;
            if (!id) return;
            repsByCasilla[id] = (repsByCasilla[id] || 0) + 1;
          });

          (this.data.casillas.features || []).forEach((f) => {
            const p = f.properties || {},
              c = f.geometry?.coordinates;
            if (!c) return;
            const cid =
              p.CASILLA_ID || (p.SECCION || "") + "-" + (p.TIPO_CASILLA || "");
            const asig = repsByCasilla[cid] || 0;
            let est = "NONE";
            if (asig >= req) est = "COVERED";
            else if (asig > 0) est = "PARTIAL";
            const fill =
              est === "COVERED"
                ? "#2ca02c"
                : est === "PARTIAL"
                ? "#ffbf00"
                : "#d62728";
            const icon = L.divIcon({
              className: "et27-casilla-dot",
              html: `<span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${fill};border:1px solid #11182722"></span>`,
              iconSize: [12, 12],
            });
            L.marker([c[1], c[0]], { icon })
              .bindPopup(
                `<div style="min-width:220px">
          <div style="font-weight:700">Casilla ${cid}</div>
          <div><b>Sección:</b> ${p.SECCION ?? "—"}</div>
          <div><b>Tipo:</b> ${p.TIPO_CASILLA ?? "B"}</div>
          <div><b>Req.Rep:</b> ${req}</div>
          <div><b>Asig.Rep:</b> ${asig}</div>
          <div><b>Estatus:</b> ${est}</div>
          ${p.DOMICILIO ? `<div><b>Domicilio:</b> ${p.DOMICILIO}</div>` : ""}
        </div>`
              )
              .addTo(g);
          });

          this.grpCasillas = g.addTo(m);
        },

        computeCoverageBySection() {
          const req = ET27_CFG.cobertura.rep_por_casilla;
          const casBySec = {};
          (this.data.casillas.features || []).forEach((f) => {
            const s = String(f.properties?.SECCION ?? "");
            if (!s) return;
            (casBySec[s] = casBySec[s] || []).push(f);
          });

          const repsByCasilla = {};
          (this.data.puntos.features || []).forEach((f) => {
            const p = f.properties || {};
            if (String(p.TIPO || "").toUpperCase() !== "REP_CASILLA") return;
            const id = p.CASILLA_ID || null;
            if (id) repsByCasilla[id] = (repsByCasilla[id] || 0) + 1;
          });

          const summary = {};
          Object.keys(casBySec).forEach((sec) => {
            const list = casBySec[sec];
            let covered = 0,
              partial = 0,
              none = 0,
              reqTot = 0,
              asigTot = 0;
            list.forEach((cf) => {
              const cid =
                cf.properties?.CASILLA_ID ||
                `${sec}-${cf.properties?.TIPO_CASILLA || ""}`;
              const asig = repsByCasilla[cid] || 0;
              asigTot += asig;
              reqTot += req;
              if (asig >= req) covered++;
              else if (asig > 0) partial++;
              else none++;
            });
            const total = list.length || 0;
            const pct = total ? Math.round((covered / total) * 100) : 0;
            summary[sec] = {
              total,
              covered,
              partial,
              none,
              reqTot,
              asigTot,
              pct,
            };
          });

          this.faltantes = Object.entries(summary)
            .map(([sec, s]) => {
              const faltan = Math.max(0, s.reqTot - s.asigTot);
              let est = "NONE";
              if (s.covered === s.total && s.total > 0) est = "COVERED";
              else if (s.covered > 0 || s.partial > 0) est = "PARTIAL";
              return {
                ambito: "SECCION",
                clave: sec,
                casillas: s.total,
                req: s.reqTot,
                asig: s.asigTot,
                faltan,
                est,
                pct: s.pct,
              };
            })
            .sort((a, b) => b.faltan - a.faltan);

          return summary;
        },

        paintSectionCoverage() {
          const m = this.ensureMap();
          if (this.grpSecCover) {
            try {
              m.removeLayer(this.grpSecCover);
            } catch (_) {}
            this.grpSecCover = null;
          }

          const sum = this.computeCoverageBySection();
          const layer = L.geoJSON(this.data.secciones, {
            style: (feat) => {
              const sec = String(feat.properties?.SECCION ?? "");
              const s = sum[sec] || { pct: 0 };
              const pct = s.pct;
              let fill = "#fee2e2";
              if (pct >= 100) fill = "#dcfce7";
              else if (pct >= 50) fill = "#fde68a";
              return {
                color: "#64748b",
                weight: 1,
                fillColor: fill,
                fillOpacity: 0.55,
              };
            },
            onEachFeature: (f, ly) => {
              const sec = String(f.properties?.SECCION ?? "");
              const s = sum[sec] || {
                total: 0,
                covered: 0,
                partial: 0,
                none: 0,
                reqTot: 0,
                asigTot: 0,
                pct: 0,
              };
              ly.bindTooltip(`Sección ${sec}: ${s.pct}%`, { sticky: true });
              ly.on("click", () => {
                try {
                  this.map.fitBounds(ly.getBounds(), { padding: [20, 20] });
                } catch (_) {}
              });
            },
          });
          this.grpSecCover = layer.addTo(m);
        },

        updateKPIs() {
          const pts = (this.data.puntos.features || []).length;
          const cas = (this.data.casillas.features || []).length;
          const secSum = this.computeCoverageBySection();
          const keys = Object.keys(secSum);
          const secCovered = keys.filter((k) => secSum[k].pct >= 100).length;

          const req = ET27_CFG.cobertura.rep_por_casilla;
          const repsByCasilla = {};
          (this.data.puntos.features || []).forEach((f) => {
            const p = f.properties || {};
            if (String(p.TIPO || "").toUpperCase() !== "REP_CASILLA") return;
            const id = p.CASILLA_ID || null;
            if (id) repsByCasilla[id] = (repsByCasilla[id] || 0) + 1;
          });
          let total = 0,
            cub = 0;
          (this.data.casillas.features || []).forEach((cf) => {
            total++;
            const cid =
              cf.properties?.CASILLA_ID ||
              `${cf.properties?.SECCION || ""}-${
                cf.properties?.TIPO_CASILLA || ""
              }`;
            const asig = repsByCasilla[cid] || 0;
            if (asig >= req) cub++;
          });
          const pctCas = total ? Math.round((cub / total) * 100) : 0;

          document.getElementById("et27-kpi-puntos").textContent =
            pts.toLocaleString("es-MX");
          document.getElementById("et27-kpi-casillas").textContent =
            cas.toLocaleString("es-MX");
          document.getElementById("et27-kpi-sec-cubiertas").textContent =
            (keys.length ? Math.round((secCovered / keys.length) * 100) : 0) +
            "%";
          document.getElementById("et27-kpi-cas-cubiertas").textContent =
            pctCas + "%";
        },

        openFaltantes() {
          const tb = document.querySelector("#et27-table tbody");
          tb.innerHTML = "";
          this.faltantes.forEach((r) => {
            const tr = document.createElement("tr");
            tr.innerHTML = `<td>${r.ambito}</td><td>${r.clave}</td><td>${r.casillas}</td>
                      <td>${r.req}</td><td>${r.asig}</td><td><b>${r.faltan}</b></td><td>${r.est}</td>`;
            tr.style.cursor = "pointer";
            tr.addEventListener("click", () => {
              if (this.grpSecCover) {
                const sec = r.clave;
                this.grpSecCover.eachLayer((ly) => {
                  if (
                    String(ly.feature?.properties?.SECCION ?? "") ===
                    String(sec)
                  ) {
                    try {
                      this.map.fitBounds(ly.getBounds(), { padding: [20, 20] });
                    } catch (_) {}
                  }
                });
              }
            });
            tb.appendChild(tr);
          });
          document.getElementById("et27-panel").style.display = "block";
        },
        closeFaltantes() {
          document.getElementById("et27-panel").style.display = "none";
        },

        exportCSV() {
          const rows = [
            [
              "Scope",
              "Key",
              "PollingPlaces",
              "ReqReps",
              "Assigned",
              "Missing",
              "Status",
              "PctSection",
            ],
          ];
          this.faltantes.forEach((r) =>
            rows.push([
              r.ambito,
              r.clave,
              r.casillas,
              r.req,
              r.asig,
              r.faltan,
              r.est,
              r.pct,
            ])
          );
          const csv = rows
            .map((r) =>
              r.map((v) => `"${String(v).replace(/"/g, '""')}"`).join(",")
            )
            .join("\n");
          const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
          const a = document.createElement("a");
          a.href = URL.createObjectURL(blob);
          a.download = "ET27_faltantes.csv";
          a.click();
          setTimeout(() => URL.revokeObjectURL(a.href), 5000);
        },
      };

      // Wire de botones (se monta una sola vez)
      (function () {
        const $ = (s) => document.querySelector(s);
        $("#et27-btn-load")?.addEventListener("click", async () => {
          try {
            await ET27.loadAll();
          } catch (e) {
            console.error(e);
            alert("No pude cargar ET-27. Revisa rutas en AT_PATHS.");
          }
        });
        $("#et27-btn-cob-sec")?.addEventListener("click", () => {
          ET27.paintSectionCoverage();
          ET27.updateKPIs();
        });
        $("#et27-btn-cob-cas")?.addEventListener("click", () => {
          ET27.paintCasillas();
        });
        $("#et27-btn-faltantes")?.addEventListener("click", () => {
          ET27.computeCoverageBySection();
          ET27.openFaltantes();
        });
        $("#et27-export-csv")?.addEventListener("click", () =>
          ET27.exportCSV()
        );
        $("#et27-close-panel")?.addEventListener("click", () =>
          ET27.closeFaltantes()
        );
      })();
    </script>
  </body>
</html>
